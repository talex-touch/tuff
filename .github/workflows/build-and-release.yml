name: Build and Release

on:
  # 手动触发（不创建标签，直接构建）
  workflow_dispatch:
    inputs:
      release_type:
        description: Release type
        required: true
        default: snapshot
        type: choice
        options:
          - snapshot
          - release

  # 标签触发（使用 bumpp 打好的标签自动触发）
  push:
    tags:
      - v*.*.*

jobs:
  build-and-release:
    name: Build and Release Tuff App
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]

    steps:
      - name: Check out git repository
        uses: actions/checkout@v4

      - name: Setup Python (for native dependencies)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install setuptools

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Dependencies
        run: npm install -g pnpm && pnpm i && pnpm approve-builds

      - name: Fix Binary Permissions
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Fixing binary permissions for Linux build..."
          # 修复所有可能的二进制文件权限
          find . -name "app-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "app-builder-bin" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "electron-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "snapcraft" -type f -exec chmod +x {} \; 2>/dev/null || true
          echo "Binary permissions fixed"

      - name: Determine Release Type
        id: release-type
        shell: bash
        run: |
          if [ "$EVENT_NAME" = "push" ]; then
            # 标签触发：从标签提取版本信息
            echo "type=release" >> $GITHUB_OUTPUT
            echo "tag=$REF_NAME" >> $GITHUB_OUTPUT
            echo "version=${REF_NAME#v}" >> $GITHUB_OUTPUT
          else
            # 手动触发：只设置构建类型，不处理版本和标签
            echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tag=" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}

      # Removed: Update Version Numbers step - no longer needed
      # Version numbers should be updated manually before creating tags

      - name: Prepare Build Environment
        shell: bash
        run: |
          # 确保输出目录存在
          mkdir -p apps/core-app/dist
          mkdir -p apps/core-app/dist/__appImage-x64
          mkdir -p apps/core-app/dist/__snap-x64
          mkdir -p apps/core-app/dist/__deb-x64
          mkdir -p apps/core-app/dist/@talex-touch
          # 设置正确的权限
          chmod -R 755 apps/core-app/dist
          echo "Build directories prepared"

      - name: Set Build Environment Variables
        shell: bash
        run: |
          # GitHub Actions 自动提供 GITHUB_SHA
          echo "GITHUB_SHA is set: ${{ github.sha }}"
          # TUFF_ENCRYPTION_KEY 从 secrets 中获取，如果不存在则为空（非官方构建）
          if [ -n "${{ secrets.TUFF_ENCRYPTION_KEY }}" ]; then
            echo "TUFF_ENCRYPTION_KEY is set (official build)"
          else
            echo "TUFF_ENCRYPTION_KEY is not set (unofficial build)"
          fi

      - name: Clean Previous Build Artifacts
        shell: bash
        run: |
          echo "Cleaning previous build artifacts..."
          # 清理可能存在的构建产物
          rm -rf apps/core-app/dist/__*
          rm -rf apps/core-app/dist/@talex-touch
          rm -rf apps/core-app/out
          # 清理 node_modules 中的缓存
          rm -rf node_modules/.cache
          rm -rf apps/core-app/node_modules/.cache
          # 清理 electron-builder 和 Wine 缓存
          rm -rf apps/core-app/.electron-builder-cache
          rm -rf ~/.cache/electron-builder
          rm -rf ~/.electron-builder-cache
          echo "Build artifacts and caches cleaned"

      - name: Clean Windows Build Artifacts
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Cleaning previous Windows build artifacts..."
          $distPath = "apps/core-app/dist"
          if (Test-Path $distPath) {
            # 删除可能存在的安装程序文件
            Get-ChildItem -Path $distPath -Recurse -Include "*.exe", "*.msi", "*.7z" | Remove-Item -Force -ErrorAction SilentlyContinue
            # 删除 win-unpacked 目录
            $unpackedPath = Join-Path $distPath "win-unpacked"
            if (Test-Path $unpackedPath) {
              Remove-Item -Path $unpackedPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            # 删除 @talex-touch 输出目录
            $outputPath = Join-Path $distPath "@talex-touch"
            if (Test-Path $outputPath) {
              Remove-Item -Path $outputPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            # 删除 NSIS 临时文件
            Get-ChildItem -Path $distPath -Recurse -Include "__uninstaller-*" | Remove-Item -Force -ErrorAction SilentlyContinue
            # 删除缓存目录
            $cachePath = Join-Path $distPath ".electron-builder-cache"
            if (Test-Path $cachePath) {
              Remove-Item -Path $cachePath -Recurse -Force -ErrorAction SilentlyContinue
            }
          }
          Write-Host "Windows build artifacts cleaned"

      - name: Check Windows Disk Space and Write Permission
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Checking disk space and write permission..."
          Get-PSDrive -PSProvider 'FileSystem' | Select-Object Name, Free, Used, @{Name='FreeGB';Expression={[math]::Round($_.Free/1GB,2)}}
          $distPath = "apps/core-app/dist"
          if (-not (Test-Path $distPath)) { New-Item -ItemType Directory -Force -Path $distPath | Out-Null }
          $testFile = Join-Path $distPath "test-write.tmp"
          try {
            Set-Content -Path $testFile -Value "test" -Encoding ASCII
            Remove-Item -Path $testFile -Force
            Write-Host "Write permission verified"
          } catch {
            Write-Error "Write permission check failed: $($_.Exception.Message)"
            exit 1
          }

      - name: Prepare Windows Build Environment
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Preparing Windows build environment..."
          $distPath = "apps/core-app/dist"
          $outputPath = Join-Path $distPath "@talex-touch"

          # 确保输出目录存在
          if (-not (Test-Path $outputPath)) {
            New-Item -ItemType Directory -Force -Path $outputPath | Out-Null
            Write-Host "Created output directory: $outputPath"
          }

          # 设置目录权限（Windows 上确保可写）
          try {
            $testFile = Join-Path $outputPath "permission-test.tmp"
            Set-Content -Path $testFile -Value "test" -Encoding ASCII
            Remove-Item -Path $testFile -Force
            Write-Host "Output directory permissions verified"
          } catch {
            Write-Error "Output directory permission test failed: $($_.Exception.Message)"
            exit 1
          }

          Write-Host "Windows build environment prepared"

      - name: Install Linux Dependencies
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Installing Linux build dependencies..."

          # 更新包列表
          sudo apt-get update -y

          # 安装基础构建工具
          sudo apt-get install -y squashfs-tools fakeroot dpkg-dev

          # 跳过 snapcraft 安装，只构建 AppImage 和 Debian 包
          echo "Skipping snapcraft installation to avoid snapd issues"
          echo "Will build AppImage and Debian packages only"

          echo "Linux build dependencies installed successfully"

      - name: Prepare Linux Build Environment
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Preparing Linux build environment..."

          # 确保所有必要的目录存在（只创建需要的目录）
          mkdir -p apps/core-app/dist/__appImage-x64
          mkdir -p apps/core-app/dist/__deb-x64
          mkdir -p apps/core-app/dist/@talex-touch

          # 设置正确的权限
          chmod -R 755 apps/core-app/dist

          # 修复 app-builder 二进制文件权限
          echo "Fixing app-builder permissions..."
          find node_modules -name "app-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find node_modules -name "app-builder-bin" -type f -exec chmod +x {} \; 2>/dev/null || true

          # 检查磁盘空间
          echo "Disk space check:"
          df -h

          echo "Linux build environment prepared successfully (AppImage + Debian only)"

      - name: Install macOS Dependencies
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # macOS 通常不需要额外依赖，但可以检查 Xcode Command Line Tools
          xcode-select --install || echo "Xcode Command Line Tools already installed"
          echo "macOS build environment ready"

      - name: Build Tuff App
        shell: bash
        env:
          GITHUB_SHA: ${{ github.sha }}
          TUFF_ENCRYPTION_KEY: ${{ secrets.TUFF_ENCRYPTION_KEY }}
          RELEASE_TYPE: ${{ steps.release-type.outputs.type }}
          RUNNER_OS: ${{ runner.os }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # 完全禁用签名相关功能
          CSC_IDENTITY_AUTO_DISCOVERY: 'false'
          CSC_LINK: ''
          CSC_KEY_PASSWORD: ''
          APPLE_ID: ''
          APPLE_ID_PASSWORD: ''
          APPLE_TEAM_ID: ''
        run: |
          set -e  # Exit immediately if a command exits with a non-zero status

          echo "Starting build process for $RUNNER_OS..."
          echo "Current directory: $(pwd)"
          echo "RELEASE_TYPE: $RELEASE_TYPE"
          echo "RUNNER_OS: $RUNNER_OS"
          echo "GITHUB_SHA: $GITHUB_SHA"

          # 检查构建环境
          echo "Checking build environment..."
          echo "Node version: $(node --version)"
          echo "pnpm version: $(pnpm --version)"

          # 检查 dist 目录
          echo "Checking dist directory before build:"
          if [ -d "apps/core-app/dist" ]; then
            echo "Dist directory exists, cleaning..."
            rm -rf apps/core-app/dist/* || echo "Cannot clean dist (may be empty)"
          else
            echo "Dist directory does not exist (will be created)"
          fi

          # 执行构建
          BUILD_FAILED=false
          set +e  # Temporarily disable exit on error to capture build failure
          if [ "$RELEASE_TYPE" = "snapshot" ]; then
            if [ "$RUNNER_OS" = "Windows" ]; then
              echo "Building Windows snapshot..."
              echo "Running: pnpm build:snapshot:win"
              pnpm build:snapshot:win || {
                BUILD_FAILED=true
                echo "ERROR: Windows snapshot build failed with exit code $?"
              }
            elif [ "$RUNNER_OS" = "macOS" ]; then
              echo "Building macOS snapshot..."
              echo "Using NODE_OPTIONS=--max-old-space-size=6144 for macOS snapshot build"
              NODE_OPTIONS="--max-old-space-size=6144" SKIP_INSTALL_APP_DEPS=true pnpm build:snapshot:mac || {
                BUILD_FAILED=true
                echo "ERROR: macOS snapshot build failed with exit code $?"
              }
            else
              echo "Building Linux snapshot..."
              pnpm build:snapshot:linux || {
                BUILD_FAILED=true
                echo "ERROR: Linux snapshot build failed with exit code $?"
              }
            fi
          else
            echo "Building release version..."
            if [ "$RUNNER_OS" = "Windows" ]; then
              echo "Building Windows release..."
              pnpm build:release:win || {
                BUILD_FAILED=true
                echo "ERROR: Windows release build failed with exit code $?"
              }
            elif [ "$RUNNER_OS" = "macOS" ]; then
              echo "Building macOS release..."
              echo "Using NODE_OPTIONS=--max-old-space-size=6144 for macOS release build"
              NODE_OPTIONS="--max-old-space-size=6144" SKIP_INSTALL_APP_DEPS=true SKIP_TYPECHECK=true pnpm build:release:mac || {
                BUILD_FAILED=true
                echo "ERROR: macOS release build failed with exit code $?"
              }
            else
              echo "Building Linux release..."
              pnpm build:release:linux || {
                BUILD_FAILED=true
                echo "ERROR: Linux release build failed with exit code $?"
              }
            fi
          fi
          set -e  # Re-enable exit on error

          # 验证构建输出
          echo ""
          echo "Verifying build output..."

          if [ "$BUILD_FAILED" = "true" ]; then
            echo "ERROR: Build step reported failure!"
            if [ -d "apps/core-app/dist" ]; then
              echo "Checking for partial build artifacts..."
              find apps/core-app/dist -type f 2>/dev/null | head -20 || echo "Cannot list files"
            fi
            exit 1
          fi

          if [ ! -d "apps/core-app/dist" ]; then
            echo "ERROR: Dist directory was not created!"
            echo "Checking if build directory exists:"
            ls -la apps/core-app/ || echo "Cannot list core-app directory"
            exit 1
          fi

          echo "✓ Dist directory exists"

          # 检查文件数量
          FILE_COUNT=$(find apps/core-app/dist -type f 2>/dev/null | wc -l || echo "0")
          echo "Total files in dist: $FILE_COUNT"

          if [ "$FILE_COUNT" = "0" ]; then
            echo "ERROR: Dist directory exists but is empty!"
            echo "Build may have failed silently. Checking dist structure:"
            ls -la apps/core-app/dist/ || echo "Cannot list dist contents"
            echo ""
            echo "Checking for any files in subdirectories:"
            find apps/core-app/dist -type f -o -type d 2>/dev/null | head -20 || echo "No files found"
            exit 1
          fi

          echo "Dist directory contents:"
          ls -la apps/core-app/dist/ || echo "Cannot list dist contents"

          echo ""
          echo "Searching for build artifacts:"
          ARTIFACTS_FOUND=false

          if [ "$RUNNER_OS" = "Windows" ]; then
            EXE_COUNT=$(find apps/core-app/dist -name "*.exe" -type f 2>/dev/null | wc -l || echo "0")
            echo "Found $EXE_COUNT .exe file(s)"
            if [ "$EXE_COUNT" -gt 0 ]; then
              find apps/core-app/dist -name "*.exe" -type f 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
          elif [ "$RUNNER_OS" = "macOS" ]; then
            # Check for .dmg files, .app directories, and .zip files (zip contains .app)
            DMG_COUNT=$(find apps/core-app/dist -name "*.dmg" -type f 2>/dev/null | wc -l || echo "0")
            APP_COUNT=$(find apps/core-app/dist -name "*.app" -type d -path "*/mac-*/*" 2>/dev/null | wc -l || echo "0")
            ZIP_COUNT=$(find apps/core-app/dist -name "*.zip" -type f 2>/dev/null | wc -l || echo "0")
            echo "Found $DMG_COUNT .dmg file(s), $APP_COUNT .app directory/directories, and $ZIP_COUNT .zip file(s)"
            if [ "$DMG_COUNT" -gt 0 ]; then
              find apps/core-app/dist -name "*.dmg" -type f 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
            if [ "$APP_COUNT" -gt 0 ]; then
              find apps/core-app/dist -name "*.app" -type d -path "*/mac-*/*" 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
            if [ "$ZIP_COUNT" -gt 0 ]; then
              find apps/core-app/dist -name "*.zip" -type f 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
          else
            APPIMAGE_COUNT=$(find apps/core-app/dist -name "*.AppImage" -type f 2>/dev/null | wc -l || echo "0")
            DEB_COUNT=$(find apps/core-app/dist -name "*.deb" -type f 2>/dev/null | wc -l || echo "0")
            SNAP_COUNT=$(find apps/core-app/dist -name "*.snap" -type f 2>/dev/null | wc -l || echo "0")
            echo "Found $APPIMAGE_COUNT .AppImage, $DEB_COUNT .deb, $SNAP_COUNT .snap file(s)"
            if [ "$APPIMAGE_COUNT" -gt 0 ] || [ "$DEB_COUNT" -gt 0 ] || [ "$SNAP_COUNT" -gt 0 ]; then
              find apps/core-app/dist \( -name "*.AppImage" -o -name "*.deb" -o -name "*.snap" \) -type f 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
          fi

          if [ "$ARTIFACTS_FOUND" = "false" ]; then
            if [ "$RUNNER_OS" = "Windows" ]; then
              echo "ERROR: No .exe files found in dist directory!"
            elif [ "$RUNNER_OS" = "macOS" ]; then
              echo "ERROR: No .dmg files, .app directories, or .zip files found in dist directory!"
            else
              echo "ERROR: No Linux artifacts (.AppImage, .deb, or .snap) found in dist directory!"
            fi
            echo "This may indicate the electron-builder step failed silently."
            echo "Check the electron-builder output above for errors."
            exit 1
          fi

          echo ""
          echo "✓ Build completed successfully"

      - name: Verify Build Artifacts
        shell: bash
        run: |
          echo "Verifying build artifacts for $RUNNER_OS..."
          if [ -d "apps/core-app/dist" ]; then
            echo "Build artifacts found:"
            find apps/core-app/dist -type f -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" | head -10
            echo "Total files in dist:"
            find apps/core-app/dist -type f | wc -l
          else
            echo "ERROR: No dist directory found!"
            exit 1
          fi

      - name: Assert Windows Installer Exists
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          $distPath = "apps/core-app/dist"
          Write-Host "Checking for Windows installer in: $distPath"
          Write-Host "Directory exists: $(Test-Path $distPath)"

          if (-not (Test-Path $distPath)) {
            Write-Error "Dist directory does not exist: $distPath"
            exit 1
          }

          Write-Host ""
          Write-Host "Listing all .exe files in dist:"
          $allExeFiles = Get-ChildItem -Path $distPath -Recurse -Include "*.exe" -ErrorAction SilentlyContinue

          if ($null -eq $allExeFiles -or $allExeFiles.Count -eq 0) {
            Write-Host "  No .exe files found"
            Write-Host ""
            Write-Host "Checking if dist directory is empty..."
            $allFiles = Get-ChildItem -Path $distPath -Recurse -ErrorAction SilentlyContinue
            if ($null -eq $allFiles -or $allFiles.Count -eq 0) {
              Write-Error "Dist directory exists but is empty. Build may have failed silently."
              Write-Host "Build artifacts check failed. Please review the build step output above."
              exit 1
            } else {
              Write-Host "Found $($allFiles.Count) files in dist (but no .exe files):"
              $allFiles | Select-Object -First 10 FullName, PSIsContainer | Format-Table -AutoSize
            }
          } else {
            $allExeFiles | ForEach-Object {
              $fileSize = [math]::Round($_.Length / 1MB, 2)
              Write-Host "  - $($_.Name) (Size: $fileSize MB, Path: $($_.FullName))"
            }
          }

          Write-Host ""
          Write-Host "Searching for installer with pattern: *-setup.exe"
          $exists = $null

          if ($null -ne $allExeFiles -and $allExeFiles.Count -gt 0) {
            $exists = $allExeFiles | Where-Object { $_.Name -like "*-setup.exe" -or $_.Name -match "-setup\.exe$" }
          }

          if ($null -eq $exists -or $exists.Count -eq 0) {
            Write-Host ""
            Write-Host "Trying alternative search patterns..."

            if ($null -ne $allExeFiles -and $allExeFiles.Count -gt 0) {
              $alt1 = $allExeFiles | Where-Object { $_.Name -like "*setup*.exe" }
              $alt2 = $allExeFiles | Where-Object { $_.Name -like "talex-touch*.exe" }

              if ($null -ne $alt1 -and $alt1.Count -gt 0) {
                Write-Host "Found files matching *setup*.exe:"
                $alt1 | Select-Object FullName, Name | Format-Table -AutoSize
              }

              if ($null -ne $alt2 -and $alt2.Count -gt 0) {
                Write-Host "Found files matching talex-touch*.exe:"
                $alt2 | Select-Object FullName, Name | Format-Table -AutoSize
              }
            }

            Write-Error "NSIS installer not found (*.exe with -setup) in $distPath"
            Write-Host ""
            Write-Host "Full directory structure:"
            Get-ChildItem -Path $distPath -Recurse | Select-Object FullName, PSIsContainer | Format-Table -AutoSize
            exit 1
          } else {
            Write-Host ""
            Write-Host "Found installer(s):"
            $exists | ForEach-Object {
              $fileSize = [math]::Round($_.Length / 1MB, 2)
              Write-Host "  - $($_.FullName) (Size: $fileSize MB)"
            }
          }

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-${{ steps.release-type.outputs.type }}
          path: apps/core-app/dist
          retention-days: 30

      - name: Cleanup Artifacts for Windows
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          $distPath = "apps/core-app/dist"
          if (-not (Test-Path $distPath)) {
            Write-Host "Dist path not found: $distPath"
            exit 0
          }

          Write-Host "Cleaning Windows artifacts (keeping .exe files only)..."

          # Remove all non-.exe files
          Get-ChildItem -Path $distPath -Recurse -File -Force |
            Where-Object { $_.Extension -ne ".exe" } |
            Remove-Item -Force -ErrorAction SilentlyContinue

          # Remove empty directories (bottom-up)
          Get-ChildItem -Path $distPath -Recurse -Directory -Force |
            Sort-Object FullName -Descending |
            ForEach-Object {
              if (-not (Get-ChildItem -Path $_.FullName -Force -ErrorAction SilentlyContinue)) {
                Remove-Item -Path $_.FullName -Force -ErrorAction SilentlyContinue
              }
            }

      - name: Cleanup Artifacts for MacOS
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # Keep .dmg files, .zip files (contain .app), and .app directories
          find apps/core-app/dist -type f ! -name "*.dmg" ! -name "*.zip" -delete 2>/dev/null || true
          find apps/core-app/dist -type d -name "mac-*" -prune -o -type d ! -name "*.app" -empty -delete 2>/dev/null || true

  create-release:
    name: Create Release
    needs: build-and-release
    runs-on: ubuntu-latest
    if: always() && (needs.build-and-release.result == 'success' || needs.build-and-release.result == 'skipped' || needs.build-and-release.result == 'failure')

    steps:
      - name: Check Build Results
        run: |
          echo "Build results:"
          echo "Windows: ${{ needs.build-and-release.result == 'success' }}"
          echo "macOS: ${{ needs.build-and-release.result == 'success' }}"
          echo "Linux: ${{ needs.build-and-release.result == 'success' }}"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Fix macOS App Permissions After Download
        shell: bash
        run: |
          # GitHub Actions upload-artifact automatically compresses to zip
          # We need to extract and fix permissions after download
          echo "Fixing macOS app permissions after artifact extraction..."
          echo "Searching for .app directories in artifacts..."

          # Find all .app directories (they may be in subdirectories after extraction)
          # Try multiple path patterns
          APP_FOUND=false
          while IFS= read -r app_dir; do
            if [ -d "$app_dir" ]; then
              APP_FOUND=true
              echo "Found .app directory: $app_dir"
              echo "Fixing permissions for: $app_dir"

              # Fix main executable
              if [ -f "$app_dir/Contents/MacOS/tuff" ]; then
                chmod +x "$app_dir/Contents/MacOS/tuff"
                echo "  ✓ Fixed main executable permissions"
              fi

              # Fix all Framework executables
              if [ -d "$app_dir/Contents/Frameworks" ]; then
                find "$app_dir/Contents/Frameworks" -type f ! -name "*.dylib" ! -name "*.plist" -exec chmod +x {} \;
                echo "  ✓ Fixed Framework executable permissions"
              fi

              # Remove quarantine attribute (if on macOS)
              if [ "$(uname)" = "Darwin" ]; then
                xattr -dr com.apple.quarantine "$app_dir" 2>/dev/null || true
                echo "  ✓ Removed quarantine attribute"
              fi
            fi
          done < <(find artifacts -type d -name "*.app" 2>/dev/null | sort)

          if [ "$APP_FOUND" = "false" ]; then
            echo "⚠️  No .app directories found in artifacts/"
            echo "Listing artifacts directory structure:"
            find artifacts -type d -maxdepth 3 | head -20
          else
            echo "✓ macOS app permissions fixed"
          fi

      - name: Determine Release Type and Tag
        id: release-info
        run: |
          if [ "$EVENT_NAME" = "push" ]; then
            # 标签触发：使用标签信息创建 release
            echo "type=release" >> $GITHUB_OUTPUT
            echo "tag=$REF_NAME" >> $GITHUB_OUTPUT
            echo "name=Release $REF_NAME" >> $GITHUB_OUTPUT
          else
            # 手动触发：创建 draft release，使用时间戳作为临时标签
            # 标签会被 release action 自动创建，但因为是 draft，不会正式发布
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tag=manual-build-$TIMESTAMP" >> $GITHUB_OUTPUT
            echo "name=Manual Build ($RELEASE_TYPE) - $TIMESTAMP" >> $GITHUB_OUTPUT
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}

      - name: List Available Artifacts
        run: |
          echo "Available artifacts:"
          find artifacts -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" -o -name "*.zip" \) | sort
          find artifacts -type d -name "*.app" -path "*/mac-*/*" | sort
          echo "Total files:"
          find artifacts -type f | wc -l
          echo "Total .app directories:"
          find artifacts -type d -name "*.app" -path "*/mac-*/*" | wc -l
          echo "Total .zip files:"
          find artifacts -type f -name "*.zip" | wc -l

      - name: Collect Release Assets
        id: release-files
        run: |
          set -euo pipefail

          # Collect files (including zip files with .app)
          mapfile -t FILES < <(find artifacts -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" -o -name "*.zip" -o -name "latest*.yml" -o -name "builder-debug.yml" \) | sort)

          if [ "${#FILES[@]}" -eq 0 ]; then
            echo "No release files found in artifacts/"
            exit 1
          fi

          mkdir -p release-assets
          declare -a OUTPUT_PATHS=()

          # Process files (including zip files)
          for file in "${FILES[@]}"; do
            relative=${file#artifacts/}
            platform=${relative%%/*}
            if [[ "$platform" == "$relative" ]]; then
              platform="common"
            fi

            base=$(basename "$file")
            target="release-assets/${platform}-${base}"
            counter=1
            while [ -e "$target" ]; do
              counter=$((counter + 1))
              target="release-assets/${platform}-${counter}-${base}"
            done

            cp "$file" "$target"
            OUTPUT_PATHS+=("$target")
          done

          {
            echo "files<<EOF"
            for path in "${OUTPUT_PATHS[@]}"; do
              echo "$path"
            done
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release-info.outputs.tag }}
          name: ${{ steps.release-info.outputs.name }}
          draft: ${{ github.event_name == 'workflow_dispatch' }}
          prerelease: ${{ steps.release-info.outputs.type == 'snapshot' }}
          files: ${{ steps.release-files.outputs.files }}
          fail_on_unmatched_files: false
          body: |
            ## Release ${{ steps.release-info.outputs.name }}

            ### Downloads
            - **Windows**: Installer (.exe)
            - **macOS**: ZIP Package (contains `tuff.app`) or Disk Image (.dmg)
            - **Linux**: AppImage and Debian packages

            ### Installation
            - **Windows**: Run the installer executable
            - **macOS**:
              - **DMG**: Mount the DMG and drag to Applications
              - **ZIP Package**:
                1. Download and extract the zip file
                2. **Double-click `tuff.app`** to launch (or right-click and select "Open" if you see a security warning)
            - **Linux**:
              - AppImage: Make executable and run
              - Debian: `sudo dpkg -i *.deb`

            ### Quick Start (macOS ZIP Package)

            The easiest way to run the app:

            1. **Download** `tuff.app.zip` from the assets above
            2. **Extract** the zip file (double-click or use `unzip`)
            3. **Double-click `tuff.app`** to launch

            **Note**: If you see "damaged and cannot be opened" error:
            - Right-click on `tuff.app` and select "Open"
            - Click "Open" in the security dialog
            - This bypasses Gatekeeper for unsigned apps

            ### Troubleshooting (macOS)

            If you encounter "Application cannot be opened" or "App is damaged" errors on macOS, follow these steps:

            #### Quick Fix Script
            We provide a fix script in the repository. Run it from the project root:
            ```bash
            ./scripts/fix-app-permissions.sh /path/to/tuff.app
            ```

            #### Manual Fix

            **1. Remove Quarantine Attribute**
            macOS Gatekeeper adds a quarantine attribute to downloaded files. Remove it:
            ```bash
            xattr -dr com.apple.quarantine /path/to/tuff.app
            ```

            **2. Fix Executable Permissions**
            Ensure the main executable has proper permissions:
            ```bash
            chmod +x /path/to/tuff.app/Contents/MacOS/tuff
            ```

            **3. Fix Helper Process Permissions**
            Fix permissions for all Helper processes (required for GPU and renderer processes):
            ```bash
            find /path/to/tuff.app/Contents/Frameworks -type f ! -name "*.dylib" ! -name "*.plist" -exec chmod +x {} \;
            ```

            #### Complete Fix Command
            Run all fixes at once:
            ```bash
            APP_PATH="/path/to/tuff.app"
            xattr -dr com.apple.quarantine "$APP_PATH"
            chmod +x "$APP_PATH/Contents/MacOS/tuff"
            find "$APP_PATH/Contents/Frameworks" -type f ! -name "*.dylib" ! -name "*.plist" -exec chmod +x {} \;
            ```

            #### Why This Happens
            - The app is currently unsigned (we will add code signing in future releases)
            - macOS Gatekeeper blocks unsigned apps from unknown developers
            - Extracting from ZIP files may reset file permissions

            #### Alternative: Right-Click to Open
            If the above doesn't work, try:
            1. Right-click on `tuff.app`
            2. Select "Open" from the context menu
            3. Click "Open" in the security dialog
            This bypasses Gatekeeper for that specific app instance.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
