name: Build and Release

on:
  # 手动触发（不创建标签，直接构建）
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'snapshot'
        type: choice
        options:
          - snapshot
          - release

  # 标签触发（使用 bumpp 打好的标签自动触发）
  push:
    tags:
      - v*.*.*

jobs:
  build-and-release:
    name: Build and Release Tuff App
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]

    steps:
      - name: Check out git repository
        uses: actions/checkout@v4

      - name: Setup Python (for native dependencies)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install setuptools

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Dependencies
        run: npm install -g pnpm && pnpm i && pnpm approve-builds

      - name: Fix Binary Permissions
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Fixing binary permissions for Linux build..."
          # 修复所有可能的二进制文件权限
          find . -name "app-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "app-builder-bin" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "electron-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "snapcraft" -type f -exec chmod +x {} \; 2>/dev/null || true
          echo "Binary permissions fixed"

      - name: Determine Release Type
        id: release-type
        shell: bash
        run: |
          if [ "$EVENT_NAME" = "push" ]; then
            # 标签触发：从标签提取版本信息
            echo "type=release" >> $GITHUB_OUTPUT
            echo "tag=$REF_NAME" >> $GITHUB_OUTPUT
            echo "version=${REF_NAME#v}" >> $GITHUB_OUTPUT
          else
            # 手动触发：只设置构建类型，不处理版本和标签
            echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tag=" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}

      - name: Update Version Numbers (tag trigger only)
        if: github.event_name == 'push'
        shell: bash
        run: |
          VERSION=${{ steps.release-type.outputs.version }}
          if [ -n "$VERSION" ]; then
            echo "Updating version to $VERSION using bumpp"
            # 使用 bumpp 更新版本（同步根目录和 apps/core-app/package.json）
            # --no-commit 和 --no-tag 确保只更新文件，不提交或创建标签
            # -y 跳过确认提示
            # 标签触发时，版本应该已经通过标签确定
            pnpm exec bumpp $VERSION --no-commit --no-tag -y || {
              # 如果 bumpp 失败（可能因为版本格式），尝试直接使用 npm version 作为后备
              echo "bumpp failed, falling back to npm version"
              npm version $VERSION --no-git-tag-version
              cd apps/core-app
              npm version $VERSION --no-git-tag-version
              cd ../..
            }
            echo "Updated version to $VERSION"
          else
            echo "No version specified, using existing version"
          fi

      - name: Prepare Build Environment
        shell: bash
        run: |
          # 确保输出目录存在
          mkdir -p apps/core-app/dist
          mkdir -p apps/core-app/dist/__appImage-x64
          mkdir -p apps/core-app/dist/__snap-x64
          mkdir -p apps/core-app/dist/__deb-x64
          mkdir -p apps/core-app/dist/@talex-touch
          # 设置正确的权限
          chmod -R 755 apps/core-app/dist
          echo "Build directories prepared"

      - name: Clean Previous Build Artifacts
        shell: bash
        run: |
          echo "Cleaning previous build artifacts..."
          # 清理可能存在的构建产物
          rm -rf apps/core-app/dist/__*
          rm -rf apps/core-app/dist/@talex-touch
          rm -rf apps/core-app/out
          # 清理 node_modules 中的缓存
          rm -rf node_modules/.cache
          rm -rf apps/core-app/node_modules/.cache
          # 清理 electron-builder 和 Wine 缓存
          rm -rf apps/core-app/.electron-builder-cache
          rm -rf ~/.cache/electron-builder
          rm -rf ~/.electron-builder-cache
          echo "Build artifacts and caches cleaned"

      - name: Clean Windows Build Artifacts
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Cleaning previous Windows build artifacts..."
          $distPath = "apps/core-app/dist"
          if (Test-Path $distPath) {
            # 删除可能存在的安装程序文件
            Get-ChildItem -Path $distPath -Recurse -Include "*.exe", "*.msi", "*.7z" | Remove-Item -Force -ErrorAction SilentlyContinue
            # 删除 win-unpacked 目录
            $unpackedPath = Join-Path $distPath "win-unpacked"
            if (Test-Path $unpackedPath) {
              Remove-Item -Path $unpackedPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            # 删除 @talex-touch 输出目录
            $outputPath = Join-Path $distPath "@talex-touch"
            if (Test-Path $outputPath) {
              Remove-Item -Path $outputPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            # 删除 NSIS 临时文件
            Get-ChildItem -Path $distPath -Recurse -Include "__uninstaller-*" | Remove-Item -Force -ErrorAction SilentlyContinue
            # 删除缓存目录
            $cachePath = Join-Path $distPath ".electron-builder-cache"
            if (Test-Path $cachePath) {
              Remove-Item -Path $cachePath -Recurse -Force -ErrorAction SilentlyContinue
            }
          }
          Write-Host "Windows build artifacts cleaned"

      - name: Check Windows Disk Space and Write Permission
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Checking disk space and write permission..."
          Get-PSDrive -PSProvider 'FileSystem' | Select-Object Name, Free, Used, @{Name='FreeGB';Expression={[math]::Round($_.Free/1GB,2)}}
          $distPath = "apps/core-app/dist"
          if (-not (Test-Path $distPath)) { New-Item -ItemType Directory -Force -Path $distPath | Out-Null }
          $testFile = Join-Path $distPath "test-write.tmp"
          try {
            Set-Content -Path $testFile -Value "test" -Encoding ASCII
            Remove-Item -Path $testFile -Force
            Write-Host "Write permission verified"
          } catch {
            Write-Error "Write permission check failed: $($_.Exception.Message)"
            exit 1
          }

      - name: Prepare Windows Build Environment
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Preparing Windows build environment..."
          $distPath = "apps/core-app/dist"
          $outputPath = Join-Path $distPath "@talex-touch"

          # 确保输出目录存在
          if (-not (Test-Path $outputPath)) {
            New-Item -ItemType Directory -Force -Path $outputPath | Out-Null
            Write-Host "Created output directory: $outputPath"
          }

          # 设置目录权限（Windows 上确保可写）
          try {
            $testFile = Join-Path $outputPath "permission-test.tmp"
            Set-Content -Path $testFile -Value "test" -Encoding ASCII
            Remove-Item -Path $testFile -Force
            Write-Host "Output directory permissions verified"
          } catch {
            Write-Error "Output directory permission test failed: $($_.Exception.Message)"
            exit 1
          }

          Write-Host "Windows build environment prepared"

      - name: Install Linux Dependencies
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Installing Linux build dependencies..."

          # 更新包列表
          sudo apt-get update -y

          # 安装基础构建工具
          sudo apt-get install -y squashfs-tools fakeroot dpkg-dev

          # 跳过 snapcraft 安装，只构建 AppImage 和 Debian 包
          echo "Skipping snapcraft installation to avoid snapd issues"
          echo "Will build AppImage and Debian packages only"

          echo "Linux build dependencies installed successfully"

      - name: Prepare Linux Build Environment
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Preparing Linux build environment..."

          # 确保所有必要的目录存在（只创建需要的目录）
          mkdir -p apps/core-app/dist/__appImage-x64
          mkdir -p apps/core-app/dist/__deb-x64
          mkdir -p apps/core-app/dist/@talex-touch

          # 设置正确的权限
          chmod -R 755 apps/core-app/dist

          # 修复 app-builder 二进制文件权限
          echo "Fixing app-builder permissions..."
          find node_modules -name "app-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find node_modules -name "app-builder-bin" -type f -exec chmod +x {} \; 2>/dev/null || true

          # 检查磁盘空间
          echo "Disk space check:"
          df -h

          echo "Linux build environment prepared successfully (AppImage + Debian only)"

      - name: Install macOS Dependencies
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # macOS 通常不需要额外依赖，但可以检查 Xcode Command Line Tools
          xcode-select --install || echo "Xcode Command Line Tools already installed"
          echo "macOS build environment ready"

      - name: Build Tuff App
        shell: bash
        run: |
          echo "Starting build process for $RUNNER_OS..."
          echo "Current directory: $(pwd)"
          echo "RELEASE_TYPE: $RELEASE_TYPE"
          echo "RUNNER_OS: $RUNNER_OS"
          
          # 检查构建环境
          echo "Checking build environment..."
          echo "Node version: $(node --version)"
          echo "pnpm version: $(pnpm --version)"
          
          # 检查 dist 目录
          echo "Checking dist directory before build:"
          if [ -d "apps/core-app/dist" ]; then
            echo "Dist directory exists, contents:"
            ls -la apps/core-app/dist/ || echo "Cannot list dist contents"
          else
            echo "Dist directory does not exist (will be created)"
          fi

          if [ "$RELEASE_TYPE" = "snapshot" ]; then
            if [ "$RUNNER_OS" = "Windows" ]; then
              echo "Building Windows snapshot..."
              echo "Running: pnpm core:build:snapshot:win"
              pnpm core:build:snapshot:win || {
                echo "ERROR: Windows snapshot build failed!"
                echo "Checking for partial build artifacts..."
                if [ -d "apps/core-app/dist" ]; then
                  echo "Dist directory contents after failed build:"
                  find apps/core-app/dist -type f 2>/dev/null | head -20 || echo "Cannot list files"
                fi
                exit 1
              }
            elif [ "$RUNNER_OS" = "macOS" ]; then
              echo "Building macOS snapshot..."
              pnpm core:build:snapshot:mac
            else
              echo "Building Linux snapshot..."
              pnpm core:build:snapshot:linux
            fi
          else
            echo "Building release version..."
            pnpm core:build || {
              echo "ERROR: Release build failed!"
              exit 1
            }
          fi

          # 验证构建输出
          echo "Verifying build output..."
          if [ -d "apps/core-app/dist" ]; then
            echo "✓ Dist directory exists"
            echo "Dist directory contents:"
            ls -la apps/core-app/dist/ || echo "Cannot list dist contents"
            
            echo "Searching for build artifacts:"
            if [ "$RUNNER_OS" = "Windows" ]; then
              find apps/core-app/dist -name "*.exe" -type f 2>/dev/null || echo "No .exe files found"
            elif [ "$RUNNER_OS" = "macOS" ]; then
              find apps/core-app/dist -name "*.dmg" -type f 2>/dev/null || echo "No .dmg files found"
            else
              find apps/core-app/dist \( -name "*.AppImage" -o -name "*.deb" -o -name "*.snap" \) -type f 2>/dev/null || echo "No Linux artifacts found"
            fi
            
            echo "Total files in dist:"
            find apps/core-app/dist -type f 2>/dev/null | wc -l || echo "Cannot count files"
            
            echo "Build completed successfully"
          else
            echo "ERROR: Build artifacts not found!"
            echo "Checking if build directory exists:"
            ls -la apps/core-app/ || echo "Cannot list core-app directory"
            exit 1
          fi
        env:
          RELEASE_TYPE: ${{ steps.release-type.outputs.type }}
          RUNNER_OS: ${{ runner.os }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # 完全禁用签名相关功能
          CSC_IDENTITY_AUTO_DISCOVERY: 'false'
          CSC_LINK: ''
          CSC_KEY_PASSWORD: ''
          APPLE_ID: ''
          APPLE_ID_PASSWORD: ''
          APPLE_TEAM_ID: ''

      - name: Verify Build Artifacts
        shell: bash
        run: |
          echo "Verifying build artifacts for $RUNNER_OS..."
          if [ -d "apps/core-app/dist" ]; then
            echo "Build artifacts found:"
            find apps/core-app/dist -type f -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" | head -10
            echo "Total files in dist:"
            find apps/core-app/dist -type f | wc -l
          else
            echo "ERROR: No dist directory found!"
            exit 1
          fi

      - name: Assert Windows Installer Exists
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          $distPath = "apps/core-app/dist"
          Write-Host "Checking for Windows installer in: $distPath"
          Write-Host "Directory exists: $(Test-Path $distPath)"
          
          if (-not (Test-Path $distPath)) {
            Write-Error "Dist directory does not exist: $distPath"
            exit 1
          }
          
          Write-Host "`nListing all .exe files in dist:"
          $allExeFiles = Get-ChildItem -Path $distPath -Recurse -Include "*.exe" -ErrorAction SilentlyContinue
          if ($allExeFiles) {
            $allExeFiles | ForEach-Object {
              Write-Host "  - $($_.FullName) (Name: $($_.Name))"
            }
          } else {
            Write-Host "  No .exe files found"
          }
          
          Write-Host "`nSearching for installer with pattern: *-setup.exe"
          $exists = $allExeFiles | Where-Object { $_.Name -like "*-setup.exe" -or $_.Name -match "-setup\.exe$" }
          
          if (-not $exists) {
            Write-Host "`nTrying alternative search patterns..."
            # Try different patterns
            $alt1 = $allExeFiles | Where-Object { $_.Name -like "*setup*.exe" }
            $alt2 = $allExeFiles | Where-Object { $_.Name -like "talex-touch*.exe" }
            
            if ($alt1) {
              Write-Host "Found files matching *setup*.exe:"
              $alt1 | Select-Object FullName, Name
            }
            if ($alt2) {
              Write-Host "Found files matching talex-touch*.exe:"
              $alt2 | Select-Object FullName, Name
            }
            
            Write-Error "NSIS installer not found (*.exe with -setup) in $distPath"
            Write-Host "`nFull directory structure:"
            Get-ChildItem -Path $distPath -Recurse | Select-Object FullName, PSIsContainer | Format-Table -AutoSize
            exit 1
          } else {
            Write-Host "`n✓ Found installer(s):"
            $exists | ForEach-Object {
              Write-Host "  - $($_.FullName) (Size: $([math]::Round($_.Length / 1MB, 2)) MB)"
            }
          }

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-${{ steps.release-type.outputs.type }}
          path: apps/core-app/dist
          retention-days: 30

      - name: Cleanup Artifacts for Windows
        if: matrix.os == 'windows-latest'
        shell: bash
        run: npx rimraf "apps/core-app/dist/!(*.exe)"

      - name: Cleanup Artifacts for MacOS
        if: matrix.os == 'macos-latest'
        shell: bash
        run: npx rimraf "apps/core-app/dist/!(*.dmg)"

  create-release:
    name: Create Release
    needs: build-and-release
    runs-on: ubuntu-latest
    if: always() && (needs.build-and-release.result == 'success' || needs.build-and-release.result == 'skipped' || needs.build-and-release.result == 'failure')

    steps:
      - name: Check Build Results
        run: |
          echo "Build results:"
          echo "Windows: ${{ needs.build-and-release.result == 'success' }}"
          echo "macOS: ${{ needs.build-and-release.result == 'success' }}"
          echo "Linux: ${{ needs.build-and-release.result == 'success' }}"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Determine Release Type and Tag
        id: release-info
        run: |
          if [ "$EVENT_NAME" = "push" ]; then
            # 标签触发：使用标签信息创建 release
            echo "type=release" >> $GITHUB_OUTPUT
            echo "tag=$REF_NAME" >> $GITHUB_OUTPUT
            echo "name=Release $REF_NAME" >> $GITHUB_OUTPUT
          else
            # 手动触发：创建 draft release，使用时间戳作为临时标签
            # 标签会被 release action 自动创建，但因为是 draft，不会正式发布
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tag=manual-build-$TIMESTAMP" >> $GITHUB_OUTPUT
            echo "name=Manual Build ($RELEASE_TYPE) - $TIMESTAMP" >> $GITHUB_OUTPUT
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}

      - name: List Available Artifacts
        run: |
          echo "Available artifacts:"
          find artifacts -type f -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" | sort
          echo "Total artifacts:"
          find artifacts -type f | wc -l

      - name: Collect Release Assets
        id: release-files
        run: |
          set -euo pipefail

          mapfile -t FILES < <(find artifacts -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" -o -name "latest*.yml" -o -name "builder-debug.yml" \) | sort)

          if [ "${#FILES[@]}" -eq 0 ]; then
            echo "No release files found in artifacts/"
            exit 1
          fi

          mkdir -p release-assets
          declare -a OUTPUT_PATHS=()

          for file in "${FILES[@]}"; do
            relative=${file#artifacts/}
            platform=${relative%%/*}
            if [[ "$platform" == "$relative" ]]; then
              platform="common"
            fi

            base=$(basename "$file")
            target="release-assets/${platform}-${base}"
            counter=1
            while [ -e "$target" ]; do
              counter=$((counter + 1))
              target="release-assets/${platform}-${counter}-${base}"
            done

            cp "$file" "$target"
            OUTPUT_PATHS+=("$target")
          done

          {
            echo "files<<EOF"
            for path in "${OUTPUT_PATHS[@]}"; do
              echo "$path"
            done
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release-info.outputs.tag }}
          name: ${{ steps.release-info.outputs.name }}
          draft: ${{ github.event_name == 'workflow_dispatch' }}
          prerelease: ${{ steps.release-info.outputs.type == 'snapshot' }}
          files: ${{ steps.release-files.outputs.files }}
          fail_on_unmatched_files: false
          body: |
            ## Release ${{ steps.release-info.outputs.name }}

            ### Downloads
            - **Windows**: Installer (.exe)
            - **macOS**: Disk Image (.dmg)
            - **Linux**: AppImage and Debian packages

            ### Installation
            - **Windows**: Run the installer executable
            - **macOS**: Mount the DMG and drag to Applications
            - **Linux**:
              - AppImage: Make executable and run
              - Debian: `sudo dpkg -i *.deb`
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
