name: Build and Release

on:
  # 手动触发
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'snapshot'
        type: choice
        options:
          - snapshot
          - release
      version:
        description: 'Version number (e.g. 1.0.0)'
        required: true
        default: '1.0.0'

  # 标签触发
  push:
    tags:
      - v*.*.*

jobs:
  build-and-release:
    name: Build and Release Tuff App
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]

    steps:
      - name: Check out git repository
        uses: actions/checkout@v4

      - name: Setup Python (for native dependencies)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install setuptools

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Dependencies
        run: npm install -g pnpm && pnpm i && pnpm approve-builds

      - name: Fix Binary Permissions
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Fixing binary permissions for Linux build..."
          # 修复所有可能的二进制文件权限
          find . -name "app-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "app-builder-bin" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "electron-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "snapcraft" -type f -exec chmod +x {} \; 2>/dev/null || true
          echo "Binary permissions fixed"

      - name: Determine Release Type
        id: release-type
        shell: bash
        run: |
          if [ "$EVENT_NAME" = "push" ]; then
            echo "type=release" >> $GITHUB_OUTPUT
            echo "tag=$REF_NAME" >> $GITHUB_OUTPUT
            echo "version=${REF_NAME#v}" >> $GITHUB_OUTPUT
          else
            echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tag=v$VERSION" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}
          VERSION: ${{ github.event.inputs.version }}

      - name: Update Version Numbers
        shell: bash
        run: |
          VERSION=${{ steps.release-type.outputs.version }}
          if [ -n "$VERSION" ]; then
            echo "Updating version to $VERSION"
            # 更新根目录 package.json
            npm version $VERSION --no-git-tag-version
            # 更新 apps/core-app/package.json
            cd apps/core-app
            npm version $VERSION --no-git-tag-version
            cd ../..
            echo "Updated version to $VERSION"
          else
            echo "No version specified, using existing version"
          fi

      - name: Prepare Build Environment
        shell: bash
        run: |
          # 确保输出目录存在
          mkdir -p apps/core-app/dist
          mkdir -p apps/core-app/dist/__appImage-x64
          mkdir -p apps/core-app/dist/__snap-x64
          mkdir -p apps/core-app/dist/__deb-x64
          mkdir -p apps/core-app/dist/@talex-touch
          # 设置正确的权限
          chmod -R 755 apps/core-app/dist
          echo "Build directories prepared"

      - name: Clean Previous Build Artifacts
        shell: bash
        run: |
          echo "Cleaning previous build artifacts..."
          # 清理可能存在的构建产物
          rm -rf apps/core-app/dist/__*
          rm -rf apps/core-app/dist/@talex-touch
          rm -rf apps/core-app/out
          # 清理 node_modules 中的缓存
          rm -rf node_modules/.cache
          rm -rf apps/core-app/node_modules/.cache
          # 清理 electron-builder 和 Wine 缓存
          rm -rf apps/core-app/.electron-builder-cache
          rm -rf ~/.cache/electron-builder
          rm -rf ~/.electron-builder-cache
          echo "Build artifacts and caches cleaned"

      - name: Clean Windows Build Artifacts
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Cleaning previous Windows build artifacts..."
          $distPath = "apps/core-app/dist"
          if (Test-Path $distPath) {
            # 删除可能存在的安装程序文件
            Get-ChildItem -Path $distPath -Recurse -Include "*.exe", "*.msi", "*.7z" | Remove-Item -Force -ErrorAction SilentlyContinue
            # 删除 win-unpacked 目录
            $unpackedPath = Join-Path $distPath "win-unpacked"
            if (Test-Path $unpackedPath) {
              Remove-Item -Path $unpackedPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            # 删除 @talex-touch 输出目录
            $outputPath = Join-Path $distPath "@talex-touch"
            if (Test-Path $outputPath) {
              Remove-Item -Path $outputPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            # 删除 NSIS 临时文件
            Get-ChildItem -Path $distPath -Recurse -Include "__uninstaller-*" | Remove-Item -Force -ErrorAction SilentlyContinue
            # 删除缓存目录
            $cachePath = Join-Path $distPath ".electron-builder-cache"
            if (Test-Path $cachePath) {
              Remove-Item -Path $cachePath -Recurse -Force -ErrorAction SilentlyContinue
            }
          }
          Write-Host "Windows build artifacts cleaned"

      - name: Check Windows Disk Space and Write Permission
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Checking disk space and write permission..."
          Get-PSDrive -PSProvider 'FileSystem' | Select-Object Name, Free, Used, @{Name='FreeGB';Expression={[math]::Round($_.Free/1GB,2)}}
          $distPath = "apps/core-app/dist"
          if (-not (Test-Path $distPath)) { New-Item -ItemType Directory -Force -Path $distPath | Out-Null }
          $testFile = Join-Path $distPath "test-write.tmp"
          try {
            Set-Content -Path $testFile -Value "test" -Encoding ASCII
            Remove-Item -Path $testFile -Force
            Write-Host "Write permission verified"
          } catch {
            Write-Error "Write permission check failed: $($_.Exception.Message)"
            exit 1
          }

      - name: Prepare Windows Build Environment
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Preparing Windows build environment..."
          $distPath = "apps/core-app/dist"
          $outputPath = Join-Path $distPath "@talex-touch"

          # 确保输出目录存在
          if (-not (Test-Path $outputPath)) {
            New-Item -ItemType Directory -Force -Path $outputPath | Out-Null
            Write-Host "Created output directory: $outputPath"
          }

          # 设置目录权限（Windows 上确保可写）
          try {
            $testFile = Join-Path $outputPath "permission-test.tmp"
            Set-Content -Path $testFile -Value "test" -Encoding ASCII
            Remove-Item -Path $testFile -Force
            Write-Host "Output directory permissions verified"
          } catch {
            Write-Error "Output directory permission test failed: $($_.Exception.Message)"
            exit 1
          }

          Write-Host "Windows build environment prepared"

      - name: Install Linux Dependencies
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Installing Linux build dependencies..."

          # 更新包列表
          sudo apt-get update -y

          # 安装基础构建工具
          sudo apt-get install -y squashfs-tools fakeroot dpkg-dev

          # 检查并重启 snapd 服务
          echo "Checking snapd service status..."
          sudo systemctl status snapd || true

          # 重启 snapd 服务以确保稳定
          sudo systemctl restart snapd
          sleep 5

          # 等待 snapd 完全启动
          timeout 60 bash -c 'until snap version; do echo "Waiting for snapd..."; sleep 2; done'

          # 安装 snapcraft
          echo "Installing snapcraft..."
          sudo snap install snapcraft --classic --timeout=300

          # 验证安装
          snapcraft --version

          echo "Linux build dependencies installed successfully"

      - name: Prepare Linux Build Environment
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Preparing Linux build environment..."

          # 确保所有必要的目录存在
          mkdir -p apps/core-app/dist/__appImage-x64
          mkdir -p apps/core-app/dist/__snap-x64
          mkdir -p apps/core-app/dist/__deb-x64
          mkdir -p apps/core-app/dist/@talex-touch

          # 设置正确的权限
          chmod -R 755 apps/core-app/dist

          # 修复 app-builder 二进制文件权限
          echo "Fixing app-builder permissions..."
          find node_modules -name "app-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find node_modules -name "app-builder-bin" -type f -exec chmod +x {} \; 2>/dev/null || true

          # 检查磁盘空间
          echo "Disk space check:"
          df -h

          # 检查 snapd 服务状态
          echo "Snapd service status:"
          sudo systemctl status snapd --no-pager || true

          # 验证 snapcraft 安装
          echo "Verifying snapcraft installation:"
          snapcraft --version || echo "Snapcraft not available"

          # 检查 snap 环境
          echo "Snap environment:"
          snap list || echo "No snaps installed"

          echo "Linux build environment prepared successfully"

      - name: Install macOS Dependencies
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # macOS 通常不需要额外依赖，但可以检查 Xcode Command Line Tools
          xcode-select --install || echo "Xcode Command Line Tools already installed"
          echo "macOS build environment ready"

      - name: Build Tuff App
        shell: bash
        run: |
          echo "Starting build process for $RUNNER_OS..."
          echo "Current directory: $(pwd)"
          echo "Available pnpm commands:"
          pnpm run --help || echo "pnpm run command not available"
          echo "Checking package.json scripts:"
          cat package.json | grep -A 20 '"scripts"' || echo "No scripts found"

          if [ "$RELEASE_TYPE" = "snapshot" ]; then
            if [ "$RUNNER_OS" = "Windows" ]; then
              echo "Building Windows snapshot..."
              pnpm core:build:snapshot:win
            elif [ "$RUNNER_OS" = "macOS" ]; then
              echo "Building macOS snapshot..."
              pnpm core:build:snapshot:mac
            else
              echo "Building Linux snapshot..."
              pnpm core:build:snapshot:linux
            fi
          else
            echo "Building release version..."
            pnpm core:build
          fi

          # 验证构建输出
          if [ -d "apps/core-app/dist" ]; then
            echo "Build artifacts found:"
            ls -la apps/core-app/dist/
            echo "Build completed successfully"
          else
            echo "ERROR: Build artifacts not found!"
            exit 1
          fi
        env:
          RELEASE_TYPE: ${{ steps.release-type.outputs.type }}
          RUNNER_OS: ${{ runner.os }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # 完全禁用签名相关功能
          CSC_IDENTITY_AUTO_DISCOVERY: 'false'
          CSC_LINK: ''
          CSC_KEY_PASSWORD: ''
          APPLE_ID: ''
          APPLE_ID_PASSWORD: ''
          APPLE_TEAM_ID: ''

      - name: Verify Build Artifacts
        shell: bash
        run: |
          echo "Verifying build artifacts for $RUNNER_OS..."
          if [ -d "apps/core-app/dist" ]; then
            echo "Build artifacts found:"
            find apps/core-app/dist -type f -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" | head -10
            echo "Total files in dist:"
            find apps/core-app/dist -type f | wc -l
          else
            echo "ERROR: No dist directory found!"
            exit 1
          fi

      - name: Assert Windows Installer Exists
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          $distPath = "apps/core-app/dist"
          $exists = Get-ChildItem -Path $distPath -Recurse -Include "*.exe" | Where-Object { $_.Name -like "*-setup.exe" }
          if (-not $exists) {
            Write-Error "NSIS installer not found (*.exe with -setup) in $distPath"
            Write-Host "Listing .exe files:"
            Get-ChildItem -Path $distPath -Recurse -Include "*.exe" | Select-Object FullName
            exit 1
          } else {
            Write-Host "Found installer(s):"
            $exists | Select-Object FullName
          }

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-${{ steps.release-type.outputs.type }}
          path: apps/core-app/dist
          retention-days: 30

      - name: Cleanup Artifacts for Windows
        if: matrix.os == 'windows-latest'
        shell: bash
        run: npx rimraf "apps/core-app/dist/!(*.exe)"

      - name: Cleanup Artifacts for MacOS
        if: matrix.os == 'macos-latest'
        shell: bash
        run: npx rimraf "apps/core-app/dist/!(*.dmg)"

  create-release:
    name: Create Release
    needs: build-and-release
    runs-on: ubuntu-latest
    if: always() && (needs.build-and-release.result == 'success' || needs.build-and-release.result == 'skipped' || needs.build-and-release.result == 'failure')

    steps:
      - name: Check Build Results
        run: |
          echo "Build results:"
          echo "Windows: ${{ needs.build-and-release.result == 'success' }}"
          echo "macOS: ${{ needs.build-and-release.result == 'success' }}"
          echo "Linux: ${{ needs.build-and-release.result == 'success' }}"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Determine Release Type and Tag
        id: release-info
        run: |
          if [ "$EVENT_NAME" = "push" ]; then
            echo "type=release" >> $GITHUB_OUTPUT
            echo "tag=$REF_NAME" >> $GITHUB_OUTPUT
            echo "name=Release $REF_NAME" >> $GITHUB_OUTPUT
          else
            echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tag=v$VERSION" >> $GITHUB_OUTPUT
            echo "name=Release v$VERSION" >> $GITHUB_OUTPUT
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}
          VERSION: ${{ github.event.inputs.version }}

      - name: List Available Artifacts
        run: |
          echo "Available artifacts:"
          find artifacts -type f -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" | sort
          echo "Total artifacts:"
          find artifacts -type f | wc -l

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release-info.outputs.tag }}
          name: ${{ steps.release-info.outputs.name }}
          draft: ${{ github.event_name == 'workflow_dispatch' }}
          prerelease: ${{ steps.release-info.outputs.type == 'snapshot' }}
          files: |
            artifacts/windows-latest-*/*
            artifacts/macos-latest-*/*
            artifacts/ubuntu-latest-*/*
          body: |
            ## Release ${{ steps.release-info.outputs.name }}

            ### Downloads
            - **Windows**: Installer (.exe)
            - **macOS**: Disk Image (.dmg)
            - **Linux**: AppImage, Snap, and Debian packages

            ### Installation
            - **Windows**: Run the installer executable
            - **macOS**: Mount the DMG and drag to Applications
            - **Linux**:
              - AppImage: Make executable and run
              - Snap: `sudo snap install --dangerous *.snap`
              - Debian: `sudo dpkg -i *.deb`
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Git Tag (for manual trigger)
        if: github.event_name == 'workflow_dispatch'
        run: |
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git tag v${{ github.event.inputs.version }}
          git push origin v${{ github.event.inputs.version }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
