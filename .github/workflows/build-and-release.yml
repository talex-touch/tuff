name: Build and Release

on:
  # 手动触发（不创建标签，直接构建）
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'snapshot'
        type: choice
        options:
          - snapshot
          - release

  # 标签触发（使用 bumpp 打好的标签自动触发）
  push:
    tags:
      - v*.*.*

jobs:
  build-and-release:
    name: Build and Release Tuff App
    runs-on: ${{ matrix.os }}

    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, macos-latest, ubuntu-latest]

    steps:
      - name: Check out git repository
        uses: actions/checkout@v4

      - name: Setup Python (for native dependencies)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install Python dependencies
        run: |
          python -m pip install setuptools

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install Dependencies
        run: npm install -g pnpm && pnpm i && pnpm approve-builds

      - name: Fix Binary Permissions
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Fixing binary permissions for Linux build..."
          # 修复所有可能的二进制文件权限
          find . -name "app-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "app-builder-bin" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "electron-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find . -name "snapcraft" -type f -exec chmod +x {} \; 2>/dev/null || true
          echo "Binary permissions fixed"

      - name: Determine Release Type
        id: release-type
        shell: bash
        run: |
          if [ "$EVENT_NAME" = "push" ]; then
            # 标签触发：从标签提取版本信息
            echo "type=release" >> $GITHUB_OUTPUT
            echo "tag=$REF_NAME" >> $GITHUB_OUTPUT
            echo "version=${REF_NAME#v}" >> $GITHUB_OUTPUT
          else
            # 手动触发：只设置构建类型，不处理版本和标签
            echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tag=" >> $GITHUB_OUTPUT
            echo "version=" >> $GITHUB_OUTPUT
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}

      # Removed: Update Version Numbers step - no longer needed
      # Version numbers should be updated manually before creating tags

      - name: Prepare Build Environment
        shell: bash
        run: |
          # 确保输出目录存在
          mkdir -p apps/core-app/dist
          mkdir -p apps/core-app/dist/__appImage-x64
          mkdir -p apps/core-app/dist/__snap-x64
          mkdir -p apps/core-app/dist/__deb-x64
          mkdir -p apps/core-app/dist/@talex-touch
          # 设置正确的权限
          chmod -R 755 apps/core-app/dist
          echo "Build directories prepared"

      - name: Clean Previous Build Artifacts
        shell: bash
        run: |
          echo "Cleaning previous build artifacts..."
          # 清理可能存在的构建产物
          rm -rf apps/core-app/dist/__*
          rm -rf apps/core-app/dist/@talex-touch
          rm -rf apps/core-app/out
          # 清理 node_modules 中的缓存
          rm -rf node_modules/.cache
          rm -rf apps/core-app/node_modules/.cache
          # 清理 electron-builder 和 Wine 缓存
          rm -rf apps/core-app/.electron-builder-cache
          rm -rf ~/.cache/electron-builder
          rm -rf ~/.electron-builder-cache
          echo "Build artifacts and caches cleaned"

      - name: Clean Windows Build Artifacts
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Cleaning previous Windows build artifacts..."
          $distPath = "apps/core-app/dist"
          if (Test-Path $distPath) {
            # 删除可能存在的安装程序文件
            Get-ChildItem -Path $distPath -Recurse -Include "*.exe", "*.msi", "*.7z" | Remove-Item -Force -ErrorAction SilentlyContinue
            # 删除 win-unpacked 目录
            $unpackedPath = Join-Path $distPath "win-unpacked"
            if (Test-Path $unpackedPath) {
              Remove-Item -Path $unpackedPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            # 删除 @talex-touch 输出目录
            $outputPath = Join-Path $distPath "@talex-touch"
            if (Test-Path $outputPath) {
              Remove-Item -Path $outputPath -Recurse -Force -ErrorAction SilentlyContinue
            }
            # 删除 NSIS 临时文件
            Get-ChildItem -Path $distPath -Recurse -Include "__uninstaller-*" | Remove-Item -Force -ErrorAction SilentlyContinue
            # 删除缓存目录
            $cachePath = Join-Path $distPath ".electron-builder-cache"
            if (Test-Path $cachePath) {
              Remove-Item -Path $cachePath -Recurse -Force -ErrorAction SilentlyContinue
            }
          }
          Write-Host "Windows build artifacts cleaned"

      - name: Check Windows Disk Space and Write Permission
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Checking disk space and write permission..."
          Get-PSDrive -PSProvider 'FileSystem' | Select-Object Name, Free, Used, @{Name='FreeGB';Expression={[math]::Round($_.Free/1GB,2)}}
          $distPath = "apps/core-app/dist"
          if (-not (Test-Path $distPath)) { New-Item -ItemType Directory -Force -Path $distPath | Out-Null }
          $testFile = Join-Path $distPath "test-write.tmp"
          try {
            Set-Content -Path $testFile -Value "test" -Encoding ASCII
            Remove-Item -Path $testFile -Force
            Write-Host "Write permission verified"
          } catch {
            Write-Error "Write permission check failed: $($_.Exception.Message)"
            exit 1
          }

      - name: Prepare Windows Build Environment
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          Write-Host "Preparing Windows build environment..."
          $distPath = "apps/core-app/dist"
          $outputPath = Join-Path $distPath "@talex-touch"

          # 确保输出目录存在
          if (-not (Test-Path $outputPath)) {
            New-Item -ItemType Directory -Force -Path $outputPath | Out-Null
            Write-Host "Created output directory: $outputPath"
          }

          # 设置目录权限（Windows 上确保可写）
          try {
            $testFile = Join-Path $outputPath "permission-test.tmp"
            Set-Content -Path $testFile -Value "test" -Encoding ASCII
            Remove-Item -Path $testFile -Force
            Write-Host "Output directory permissions verified"
          } catch {
            Write-Error "Output directory permission test failed: $($_.Exception.Message)"
            exit 1
          }

          Write-Host "Windows build environment prepared"

      - name: Install Linux Dependencies
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Installing Linux build dependencies..."

          # 更新包列表
          sudo apt-get update -y

          # 安装基础构建工具
          sudo apt-get install -y squashfs-tools fakeroot dpkg-dev

          # 跳过 snapcraft 安装，只构建 AppImage 和 Debian 包
          echo "Skipping snapcraft installation to avoid snapd issues"
          echo "Will build AppImage and Debian packages only"

          echo "Linux build dependencies installed successfully"

      - name: Prepare Linux Build Environment
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: |
          echo "Preparing Linux build environment..."

          # 确保所有必要的目录存在（只创建需要的目录）
          mkdir -p apps/core-app/dist/__appImage-x64
          mkdir -p apps/core-app/dist/__deb-x64
          mkdir -p apps/core-app/dist/@talex-touch

          # 设置正确的权限
          chmod -R 755 apps/core-app/dist

          # 修复 app-builder 二进制文件权限
          echo "Fixing app-builder permissions..."
          find node_modules -name "app-builder" -type f -exec chmod +x {} \; 2>/dev/null || true
          find node_modules -name "app-builder-bin" -type f -exec chmod +x {} \; 2>/dev/null || true

          # 检查磁盘空间
          echo "Disk space check:"
          df -h

          echo "Linux build environment prepared successfully (AppImage + Debian only)"

      - name: Install macOS Dependencies
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # macOS 通常不需要额外依赖，但可以检查 Xcode Command Line Tools
          xcode-select --install || echo "Xcode Command Line Tools already installed"
          echo "macOS build environment ready"

      - name: Build Tuff App
        shell: bash
        run: |
          set -e  # Exit immediately if a command exits with a non-zero status

          echo "Starting build process for $RUNNER_OS..."
          echo "Current directory: $(pwd)"
          echo "RELEASE_TYPE: $RELEASE_TYPE"
          echo "RUNNER_OS: $RUNNER_OS"

          # 检查构建环境
          echo "Checking build environment..."
          echo "Node version: $(node --version)"
          echo "pnpm version: $(pnpm --version)"

          # 检查 dist 目录
          echo "Checking dist directory before build:"
          if [ -d "apps/core-app/dist" ]; then
            echo "Dist directory exists, cleaning..."
            rm -rf apps/core-app/dist/* || echo "Cannot clean dist (may be empty)"
          else
            echo "Dist directory does not exist (will be created)"
          fi

          # 执行构建
          BUILD_FAILED=false
          set +e  # Temporarily disable exit on error to capture build failure
          if [ "$RELEASE_TYPE" = "snapshot" ]; then
            if [ "$RUNNER_OS" = "Windows" ]; then
              echo "Building Windows snapshot..."
              echo "Running: pnpm core:build:snapshot:win"
              pnpm core:build:snapshot:win || {
                BUILD_FAILED=true
                echo "ERROR: Windows snapshot build failed with exit code $?"
              }
            elif [ "$RUNNER_OS" = "macOS" ]; then
              echo "Building macOS snapshot..."
              pnpm core:build:snapshot:mac || {
                BUILD_FAILED=true
                echo "ERROR: macOS snapshot build failed with exit code $?"
              }
            else
              echo "Building Linux snapshot..."
              pnpm core:build:snapshot:linux || {
                BUILD_FAILED=true
                echo "ERROR: Linux snapshot build failed with exit code $?"
              }
            fi
          else
            echo "Building release version..."
            pnpm core:build || {
              BUILD_FAILED=true
              echo "ERROR: Release build failed with exit code $?"
            }
          fi
          set -e  # Re-enable exit on error

          # 验证构建输出
          echo ""
          echo "Verifying build output..."

          if [ "$BUILD_FAILED" = "true" ]; then
            echo "ERROR: Build step reported failure!"
            if [ -d "apps/core-app/dist" ]; then
              echo "Checking for partial build artifacts..."
              find apps/core-app/dist -type f 2>/dev/null | head -20 || echo "Cannot list files"
            fi
            exit 1
          fi

          if [ ! -d "apps/core-app/dist" ]; then
            echo "ERROR: Dist directory was not created!"
            echo "Checking if build directory exists:"
            ls -la apps/core-app/ || echo "Cannot list core-app directory"
            exit 1
          fi

          echo "✓ Dist directory exists"

          # 检查文件数量
          FILE_COUNT=$(find apps/core-app/dist -type f 2>/dev/null | wc -l || echo "0")
          echo "Total files in dist: $FILE_COUNT"

          if [ "$FILE_COUNT" = "0" ]; then
            echo "ERROR: Dist directory exists but is empty!"
            echo "Build may have failed silently. Checking dist structure:"
            ls -la apps/core-app/dist/ || echo "Cannot list dist contents"
            echo ""
            echo "Checking for any files in subdirectories:"
            find apps/core-app/dist -type f -o -type d 2>/dev/null | head -20 || echo "No files found"
            exit 1
          fi

          echo "Dist directory contents:"
          ls -la apps/core-app/dist/ || echo "Cannot list dist contents"

          echo ""
          echo "Searching for build artifacts:"
          ARTIFACTS_FOUND=false

          if [ "$RUNNER_OS" = "Windows" ]; then
            EXE_COUNT=$(find apps/core-app/dist -name "*.exe" -type f 2>/dev/null | wc -l || echo "0")
            echo "Found $EXE_COUNT .exe file(s)"
            if [ "$EXE_COUNT" -gt 0 ]; then
              find apps/core-app/dist -name "*.exe" -type f 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
          elif [ "$RUNNER_OS" = "macOS" ]; then
            # Check for both .dmg files and .app directories (dir mode generates .app only)
            DMG_COUNT=$(find apps/core-app/dist -name "*.dmg" -type f 2>/dev/null | wc -l || echo "0")
            APP_COUNT=$(find apps/core-app/dist -name "*.app" -type d -path "*/mac-*/*" 2>/dev/null | wc -l || echo "0")
            echo "Found $DMG_COUNT .dmg file(s) and $APP_COUNT .app directory/directories"
            if [ "$DMG_COUNT" -gt 0 ]; then
              find apps/core-app/dist -name "*.dmg" -type f 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
            if [ "$APP_COUNT" -gt 0 ]; then
              find apps/core-app/dist -name "*.app" -type d -path "*/mac-*/*" 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
          else
            APPIMAGE_COUNT=$(find apps/core-app/dist -name "*.AppImage" -type f 2>/dev/null | wc -l || echo "0")
            DEB_COUNT=$(find apps/core-app/dist -name "*.deb" -type f 2>/dev/null | wc -l || echo "0")
            SNAP_COUNT=$(find apps/core-app/dist -name "*.snap" -type f 2>/dev/null | wc -l || echo "0")
            echo "Found $APPIMAGE_COUNT .AppImage, $DEB_COUNT .deb, $SNAP_COUNT .snap file(s)"
            if [ "$APPIMAGE_COUNT" -gt 0 ] || [ "$DEB_COUNT" -gt 0 ] || [ "$SNAP_COUNT" -gt 0 ]; then
              find apps/core-app/dist \( -name "*.AppImage" -o -name "*.deb" -o -name "*.snap" \) -type f 2>/dev/null
              ARTIFACTS_FOUND=true
            fi
          fi

          if [ "$ARTIFACTS_FOUND" = "false" ]; then
            if [ "$RUNNER_OS" = "Windows" ]; then
              echo "ERROR: No .exe files found in dist directory!"
            elif [ "$RUNNER_OS" = "macOS" ]; then
              echo "ERROR: No .dmg files or .app directories found in dist directory!"
            else
              echo "ERROR: No Linux artifacts (.AppImage, .deb, or .snap) found in dist directory!"
            fi
            echo "This may indicate the electron-builder step failed silently."
            echo "Check the electron-builder output above for errors."
            exit 1
          fi

          echo ""
          echo "✓ Build completed successfully"
        env:
          RELEASE_TYPE: ${{ steps.release-type.outputs.type }}
          RUNNER_OS: ${{ runner.os }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # 完全禁用签名相关功能
          CSC_IDENTITY_AUTO_DISCOVERY: 'false'
          CSC_LINK: ''
          CSC_KEY_PASSWORD: ''
          APPLE_ID: ''
          APPLE_ID_PASSWORD: ''
          APPLE_TEAM_ID: ''

      - name: Verify Build Artifacts
        shell: bash
        run: |
          echo "Verifying build artifacts for $RUNNER_OS..."
          if [ -d "apps/core-app/dist" ]; then
            echo "Build artifacts found:"
            find apps/core-app/dist -type f -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" | head -10
            echo "Total files in dist:"
            find apps/core-app/dist -type f | wc -l
          else
            echo "ERROR: No dist directory found!"
            exit 1
          fi

      - name: Assert Windows Installer Exists
        if: matrix.os == 'windows-latest'
        shell: powershell
        run: |
          $distPath = "apps/core-app/dist"
          Write-Host "Checking for Windows installer in: $distPath"
          Write-Host "Directory exists: $(Test-Path $distPath)"

          if (-not (Test-Path $distPath)) {
            Write-Error "Dist directory does not exist: $distPath"
            exit 1
          }

          Write-Host ""
          Write-Host "Listing all .exe files in dist:"
          $allExeFiles = Get-ChildItem -Path $distPath -Recurse -Include "*.exe" -ErrorAction SilentlyContinue

          if ($null -eq $allExeFiles -or $allExeFiles.Count -eq 0) {
            Write-Host "  No .exe files found"
            Write-Host ""
            Write-Host "Checking if dist directory is empty..."
            $allFiles = Get-ChildItem -Path $distPath -Recurse -ErrorAction SilentlyContinue
            if ($null -eq $allFiles -or $allFiles.Count -eq 0) {
              Write-Error "Dist directory exists but is empty. Build may have failed silently."
              Write-Host "Build artifacts check failed. Please review the build step output above."
              exit 1
            } else {
              Write-Host "Found $($allFiles.Count) files in dist (but no .exe files):"
              $allFiles | Select-Object -First 10 FullName, PSIsContainer | Format-Table -AutoSize
            }
          } else {
            $allExeFiles | ForEach-Object {
              $fileSize = [math]::Round($_.Length / 1MB, 2)
              Write-Host "  - $($_.Name) (Size: $fileSize MB, Path: $($_.FullName))"
            }
          }

          Write-Host ""
          Write-Host "Searching for installer with pattern: *-setup.exe"
          $exists = $null

          if ($null -ne $allExeFiles -and $allExeFiles.Count -gt 0) {
            $exists = $allExeFiles | Where-Object { $_.Name -like "*-setup.exe" -or $_.Name -match "-setup\.exe$" }
          }

          if ($null -eq $exists -or $exists.Count -eq 0) {
            Write-Host ""
            Write-Host "Trying alternative search patterns..."

            if ($null -ne $allExeFiles -and $allExeFiles.Count -gt 0) {
              $alt1 = $allExeFiles | Where-Object { $_.Name -like "*setup*.exe" }
              $alt2 = $allExeFiles | Where-Object { $_.Name -like "talex-touch*.exe" }

              if ($null -ne $alt1 -and $alt1.Count -gt 0) {
                Write-Host "Found files matching *setup*.exe:"
                $alt1 | Select-Object FullName, Name | Format-Table -AutoSize
              }

              if ($null -ne $alt2 -and $alt2.Count -gt 0) {
                Write-Host "Found files matching talex-touch*.exe:"
                $alt2 | Select-Object FullName, Name | Format-Table -AutoSize
              }
            }

            Write-Error "NSIS installer not found (*.exe with -setup) in $distPath"
            Write-Host ""
            Write-Host "Full directory structure:"
            Get-ChildItem -Path $distPath -Recurse | Select-Object FullName, PSIsContainer | Format-Table -AutoSize
            exit 1
          } else {
            Write-Host ""
            Write-Host "Found installer(s):"
            $exists | ForEach-Object {
              $fileSize = [math]::Round($_.Length / 1MB, 2)
              Write-Host "  - $($_.FullName) (Size: $fileSize MB)"
            }
          }

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.os }}-${{ steps.release-type.outputs.type }}
          path: apps/core-app/dist
          retention-days: 30

      - name: Cleanup Artifacts for Windows
        if: matrix.os == 'windows-latest'
        shell: bash
        run: npx rimraf "apps/core-app/dist/!(*.exe)"

      - name: Cleanup Artifacts for MacOS
        if: matrix.os == 'macos-latest'
        shell: bash
        run: |
          # Keep both .dmg files and .app directories
          find apps/core-app/dist -type f ! -name "*.dmg" -delete 2>/dev/null || true
          find apps/core-app/dist -type d -name "mac-*" -prune -o -type d ! -name "*.app" -empty -delete 2>/dev/null || true

  create-release:
    name: Create Release
    needs: build-and-release
    runs-on: ubuntu-latest
    if: always() && (needs.build-and-release.result == 'success' || needs.build-and-release.result == 'skipped' || needs.build-and-release.result == 'failure')

    steps:
      - name: Check Build Results
        run: |
          echo "Build results:"
          echo "Windows: ${{ needs.build-and-release.result == 'success' }}"
          echo "macOS: ${{ needs.build-and-release.result == 'success' }}"
          echo "Linux: ${{ needs.build-and-release.result == 'success' }}"

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Determine Release Type and Tag
        id: release-info
        run: |
          if [ "$EVENT_NAME" = "push" ]; then
            # 标签触发：使用标签信息创建 release
            echo "type=release" >> $GITHUB_OUTPUT
            echo "tag=$REF_NAME" >> $GITHUB_OUTPUT
            echo "name=Release $REF_NAME" >> $GITHUB_OUTPUT
          else
            # 手动触发：创建 draft release，使用时间戳作为临时标签
            # 标签会被 release action 自动创建，但因为是 draft，不会正式发布
            TIMESTAMP=$(date +%Y%m%d-%H%M%S)
            echo "type=$RELEASE_TYPE" >> $GITHUB_OUTPUT
            echo "tag=manual-build-$TIMESTAMP" >> $GITHUB_OUTPUT
            echo "name=Manual Build ($RELEASE_TYPE) - $TIMESTAMP" >> $GITHUB_OUTPUT
          fi
        env:
          EVENT_NAME: ${{ github.event_name }}
          REF_NAME: ${{ github.ref_name }}
          RELEASE_TYPE: ${{ github.event.inputs.release_type }}

      - name: List Available Artifacts
        run: |
          echo "Available artifacts:"
          find artifacts -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" \) | sort
          find artifacts -type d -name "*.app" -path "*/mac-*/*" | sort
          echo "Total files:"
          find artifacts -type f | wc -l
          echo "Total .app directories:"
          find artifacts -type d -name "*.app" -path "*/mac-*/*" | wc -l

      - name: Collect Release Assets
        id: release-files
        run: |
          set -euo pipefail

          # Collect files and .app directories
          mapfile -t FILES < <(find artifacts -type f \( -name "*.exe" -o -name "*.dmg" -o -name "*.AppImage" -o -name "*.snap" -o -name "*.deb" -o -name "latest*.yml" -o -name "builder-debug.yml" \) | sort)
          mapfile -t APP_DIRS < <(find artifacts -type d -name "*.app" -path "*/mac-*/*" | sort)

          if [ "${#FILES[@]}" -eq 0 ] && [ "${#APP_DIRS[@]}" -eq 0 ]; then
            echo "No release files or .app directories found in artifacts/"
            exit 1
          fi

          mkdir -p release-assets
          declare -a OUTPUT_PATHS=()

          # Process files
          for file in "${FILES[@]}"; do
            relative=${file#artifacts/}
            platform=${relative%%/*}
            if [[ "$platform" == "$relative" ]]; then
              platform="common"
            fi

            base=$(basename "$file")
            target="release-assets/${platform}-${base}"
            counter=1
            while [ -e "$target" ]; do
              counter=$((counter + 1))
              target="release-assets/${platform}-${counter}-${base}"
            done

            cp "$file" "$target"
            OUTPUT_PATHS+=("$target")
          done

          # Process .app directories (package as zip)
          for app_dir in "${APP_DIRS[@]}"; do
            relative=${app_dir#artifacts/}
            platform=${relative%%/*}
            if [[ "$platform" == "$relative" ]]; then
              platform="common"
            fi

            base=$(basename "$app_dir")
            zip_name="${base}.zip"
            target="release-assets/${platform}-${zip_name}"
            counter=1
            while [ -e "$target" ]; do
              counter=$((counter + 1))
              target="release-assets/${platform}-${counter}-${zip_name}"
            done

            # Create zip from .app directory
            app_parent=$(dirname "$app_dir")
            abs_target=$(realpath "$target" 2>/dev/null || echo "$(pwd)/$target")
            cd "$app_parent" || exit 1
            zip -r "$abs_target" "$base" -q
            cd - > /dev/null || exit 1
            OUTPUT_PATHS+=("$target")
          done

          {
            echo "files<<EOF"
            for path in "${OUTPUT_PATHS[@]}"; do
              echo "$path"
            done
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release-info.outputs.tag }}
          name: ${{ steps.release-info.outputs.name }}
          draft: ${{ github.event_name == 'workflow_dispatch' }}
          prerelease: ${{ steps.release-info.outputs.type == 'snapshot' }}
          files: ${{ steps.release-files.outputs.files }}
          fail_on_unmatched_files: false
          body: |
            ## Release ${{ steps.release-info.outputs.name }}

            ### Downloads
            - **Windows**: Installer (.exe)
            - **macOS**: Disk Image (.dmg)
            - **Linux**: AppImage and Debian packages

            ### Installation
            - **Windows**: Run the installer executable
            - **macOS**: Mount the DMG and drag to Applications
            - **Linux**:
              - AppImage: Make executable and run
              - Debian: `sudo dpkg -i *.deb`
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
